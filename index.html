<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>reveal.js - The HTML Presentation Framework</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/moon.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

        <section>
          <h1>Building Maintainable Software with TDD</h1>
          <p>
            How I learned to stop worrying and love failure.
          </p>
        </section>

        <section>
          <blockquote>
            <small>
              &ldquo;Sometimes I hate myself for trying to be so bold,
              <br />
              but nothing ever seems to get this story told.&rdquo;
              <br />
              <br />
              &mdash;"Hey Lover" by Blake Mills
            </small>
          </blockquote>
        </section>

        <section>
          <section>
            <h3>What is TDD?</h3>
          </section>

          <section>
            <h4>Definition.</h4>
            <p>
              <small>
                (I'm sure you already know this.)
                <br />
                <br />
                TDD stands for test-driven development.
              </small>
            </p>
          </section>

          <section>
            <h4>Practice.</h4>
            <p>
              <small>
                <br />
                <br />
                Write the tests before the code.
                <br />
                Let testing feedback drive development.
              </small>
            </p>
          </section>

          <section>
            <h4>Mindset.</h4>
            <p>
              <small>
                Embrace failure.
                <br />
                Tight feedback loops.
                <br />
                Small, well defined steps.
              </small>
            </p>
          </section>
        </section>

        <section>
          <section>
            <h3>Why do TDD?</h3>
          </section>

          <section>
            <h4>It's better than not.</h4>
            <p>
              <small>
                We all test, even if it's just manual testing.
                <br />
                Manual testing is expensive, tedious, and error-prone.
                <br />
                Automated testing minimizes those problems.
                <br />
                TDD is an effective way to create automated tests.
              </small>
            </p>
          </section>

          <section>
            <h4>TDD minimizes the lifespan of defects.</h4>
            <p>
              <small>
                Defects are usually caught at creation time,
                <br />
                when they're the least painful and expensive to fix.
              </small>
            </p>
          </section>

          <section>
            <table>
              <tbody>
                <tr>
                  <td></td>
                  <td><strong>Requirements</strong></td>
                  <td><strong>Architecture</strong></td>
                  <td><strong>Construction</strong></td>
                  <td><strong>System Test</strong></td>
                  <td><strong>Release</strong></td>
                </tr>
                <tr>
                  <td><strong>Requirements</strong></td>
                  <td>1</td>
                  <td class="important">3</td>
                  <td class="important">5-10</td>
                  <td class="important">10</td>
                  <td class="important">10-100</td>
                </tr>
                <tr>
                  <td><strong>Architecture</strong></td>
                  <td>&mdash;</td>
                  <td>1</td>
                  <td class="important">10</td>
                  <td class="important">15</td>
                  <td class="important">25-100</td>
                </tr>
                <tr>
                  <td><strong>Construction</strong></td>
                  <td>&mdash;</td>
                  <td>&mdash;</td>
                  <td>1</td>
                  <td class="important">10</td>
                  <td class="important">10-25</td>
                </tr>
              </tbody>
              <caption>
                Cost multiplier for defect fixes based on creation and detection times.
                <br />
                —Hewlett-Packard, IMB, Hughes Aircraft, TRW, et al 1976-2004
              </caption>
            </table>
          </section>

          <section>
            <blockquote>
              <small>
                &ldquo;TDD teams produced code that was 60 to 90 percent
                <br />
                better in terms of defect density than non-TDD teams.&rdquo;
                <br />
                <br />
                &mdash;Microsoft Research, 2008
              </small>
            </blockquote>
          </section>

          <section>
            <h4>TDD increases coverage.</h4>
            <p>
              <small>
                If we rarely write code except to make a failing test pass,
                <br />
                then most of the code will be covered by tests.
              </small>
            </p>
          </section>

          <section>
            <h4>TDD improves design.</h4>
            <p>
              <small>
                Tests are the first consumer of code.
                <br />
                If tests are easy to write, then code is usually easier to use.
                <br />
                Tests enable safe refactoring both now and later.
              </small>
            </p>
          </section>

          <section>
            <h4>TDD increases agility.</h4>

            <p>
              <small>
                It’s hard to have agility without clean code.
                <br />
                It’s hard to have clean code without refactoring.
                <br />
                It’s hard to safely refactor without automated tests.
              </small>
            </p>
          </section>

          <section>
            <blockquote>
              <small>
                &ldquo;Don't touch anything that doesn't have [test] coverage.
                <br />
                Otherwise, you're not refactoring; you're just changing sh*t.&rdquo;
                <br />
                <br />
                &mdash;Hamlet D'Arcy
              </small>
            </blockquote>
          </section>

          <section>
            <h4>TDD documents the code.</h4>
            <p>
              <small>
                Examples of code in tests must be correct.
                <br />
                Well written tests help us readily understand the code.
                <br />
                Due to good test coverage, most code will be documented this way.
              </small>
            </p>
          </section>

          <section>
            <h4>TDD helps us focus.</h4>
            <p>
              <small>
                Failing tests tell us what to work on.
                <br />
                Focus equals speed.
              </small>
            </p>
          </section>

          <section>
            <h4>TDD helps us finish.</h4>
            <p>
              <small>
                Passing tests tell us when we’re done.
                <br />
                Minimizes slapdash code.
                <br />
                Minimizes gold-plated code.
              </small>
            </p>
          </section>

          <section>
            <h4>TDD fosters predictable schedules.</h4>
            <p>
              <small>
                Fewer defects means less debugging.
                <br />
                Debugging is a huge unknown.
              </small>
            </p>
          </section>
        </section>

        <section>
          <section>
            <h3>When to do TDD?</h3>
          </section>

          <section>
            <h4>All the time, from the start.</h4>
            <p>
              <small>
                Test especially when it’s hard.
                <br />
                Difficulty testing is very useful design feedback.
              </small>
            </p>
          </section>
        </section>

        <section>
          <section>
            <h3>How to do TDD?</h3>
          </section>

          <section>
            <h4>Red, green, refactor.</h4>
            <p>
              <small>
                Write a failing test, make it pass, clean up the mess.
                <br />
                Regularly check for architectural problems.
              </small>
            </p>
          </section>

          <section>
            <h4>Building new software?</h4>
            <p>
              <small>
                Build a &ldquo;walking skeleton&rdquo; first.
                <br />
                <br />
                Least amount of functionality that’s automatically
                <br />
                buildable, deployable, and testable end-to-end.
                <br />
                <br />
                Architecture, infrastructure, and features should evolve together.
              </small>
            </p>
          </section>

          <section>
            <h4>Changing existing software?</h4>
            <blockquote>
              <small>
                &ldquo;For each desired change, make the change easy
                <br />
                (warning: this may be hard), then make the easy change.&rdquo;
                <br />
                <br />
                &mdash;Kent Beck
              </small>
            </blockquote>
          </section>

          <section>
            <h4>Build from outside to inside, inputs to outputs.</h4>
            <p>
              <small>
                The user’s needs come first.
                <br />
                (“User” could mean “developer.”)
              </small>
            </p>
          </section>

          <section>
            <h4>Write tests at these levels:</h4>
            <small>
              <ul>
                <li><strong>Acceptance</strong> &mdash; components are wired together correctly.</li>
                <li><strong>Unit</strong> &mdash; components work correctly, and are easy to use.</li>
                <li><strong>Integration</strong> &mdash; this system works correctly with other systems.</li>
              </ul>
            </small>
          </section>

          <section>
            <h4>Write a failing acceptance test first.</h4>
            <p>
              <small>
                Clearly express desired <strong>system</strong> behavior.
                <br />
                Ensure test failure messages are helpful.
                <br />
                Covers a single, small &ldquo;feature.&rdquo;
              </small>
            </p>
          </section>

          <section>
            <h4>Then write a failing {unit, integration} test.</h4>
            <p>
              <small>
                Clearly express desired <strong>{component, interaction}</strong> behavior.
                <br />
                Ensure test failure messages are helpful.
              </small>
            </p>
          </section>

          <section>
            <h4>Then write code to make the failing test pass.</h4>
            <p>
              <small>
                Keep it simple.
                <br />
                Don’t write more than is enough to pass.
              </small>
            </p>
          </section>

          <section>
            <h4>Then refactor.</h4>
            <p>
              <small>
                Make the code clean.
                <br />
                <br />
                <span class="important">Important, but often skipped!</span>
                <br />
                <br />
                Possibilities include all of software engineering.
              </small>
            </p>
          </section>

          <section>
            <h4>Refactoring: a good start.</h4>
            <small>
              <ul>
                <li>Good names.</li>
                <li>Short (pure) methods.</li>
                <li>Short classes.</li>
                <br />
                <li>Do one thing.</li>
                <li>Don't repeat yourself.</li>
                <li>Uniform levels of abstraction.</li>
              </ul>
            </small>
          </section>

          <section>
            <h4>Rinse and repeat.</h4>
            <p>
              <small>
                Build more {unit, integration} tests until the code
                <br />
                is correct, and the acceptance test passes.
              </small>
            </p>
          </section>

          <section>
            <h4>What kinds of tests?</h4>
            <small>
              <ul>
                <li><strong>Output</strong> &mdash; values returned for various inputs are correct.</li>
                <li><strong>Side effects</strong> &mdash; changes observable to “outside” are correct.</li>
                <li><strong>Boundaries</strong> &mdash; edge cases are handled correctly.</li>
                <li><strong>Errors</strong> &mdash; abnormal events are handled correctly.</li>
                <li><strong>Coverage</strong> &mdash; critical components are well tested.</li>
              </ul>
            </small>
          </section>

          <section>
            <h4>Make tests fast, and expressive.</h4>
            <p>
              <small>
                We’re running tests constantly.
                <br />
                The feedback loop must be fast.
                <br />
                Don’t sacrifice clarity.
              </small>
            </p>
          </section>

          <section>
            <h4>Test units in isolation.</h4>
            <p>
              <small>
                Like a science experiment.
                <br />
                Control variables and external contamination.
                <br />
                Results should be reproducible.
                <br />
                <br />
                Use <strong>test doubles</strong> (mocks, stubs, spies, etc.) to:
                <br />
                improve isolation, increase speed (avoid I/O),
                <br />
                improve design, and discover collaborators.
              </small>
            </p>
          </section>

          <section>
            <h4>Test one small behavior per test.</h4>
            <p>
              <small>
                One assertion, or a couple of test double expectations.
                <br />
                Makes failures much easier to troubleshoot.
              </small>
            </p>
          </section>
        </section>

        <section>
          <h3>Coda</h3>
          <p>
            <small>
              REPL-driven development.
              <br />
              Property or generative testing.
              <br />
              Mutation and fuzz testing.
              <br />
              Transformation priority premise (Uncle Bob).
            </small>
          </p>
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
